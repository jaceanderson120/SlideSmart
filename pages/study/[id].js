import { useRouter } from "next/router";
import { useEffect, useRef, useState } from "react";
import styled, { useTheme } from "styled-components";
import Link from "next/link";
import ShareModal from "@/components/modals/ShareModal";
import CreateFlashcardModal from "@/components/modals/CreateFlashcardModal";
import FlashcardViewer from "@/components/studyGuide/FlashcardViewer";
import {
  updateStudyGuideExtractedData,
  uploadStudyGuideToFirebase,
  updateStudyGuideHiddenExplanations,
} from "@/firebase/database";
import { Forward, Sparkles, Trash2, X, Zap } from "lucide-react";
import { useStateContext } from "@/context/StateContext";
import Chatbot from "@/components/studyGuide/Chatbot";
import { toast } from "react-toastify";
import ConfirmationModal from "@/components/modals/ConfirmationModal";
import AddSectionsContainer from "@/components/studyGuide/AddSectionsContainer";
import AddTopicModal from "@/components/modals/AddTopicModal";
import {
  generateExample,
  generateExplanation,
  generateQuestionAnswer,
} from "@/utils/generateStudyGuideSections";
import { useSearchParams } from "next/navigation";
import Sidebar from "@/components/studyGuide/Sidebar";
import Video from "@/components/studyGuide/Video";
import IconButton from "@/components/IconButton";
import TopicSection from "@/components/studyGuide/TopicSection";
import InfoContainer from "@/components/studyGuide/InfoContainer";
import TopicWrapper from "@/components/studyGuide/TopicWrapper";
import useFetchStudyGuide from "@/hooks/useFetchStudyGuide";
import useDeviceWidth from "@/hooks/useDeviceWidth";
import useDragAndDrop from "@/hooks/useDragAndDrop";
import useActiveTopic from "@/hooks/useActiveTopic";
import useFlashcards from "@/hooks/useFlashcards";

function getViewerUrl(url) {
  const viewerUrl = `https://drive.google.com/viewerng/viewer?embedded=true&url=${encodeURIComponent(
    url
  )}`;
  return viewerUrl;
}

const Study = () => {
  const router = useRouter();
  const { id } = router.query;
  const [initialStudyGuide, setInitialStudyGuide] = useState(null);
  const [activeTopic, setActiveTopic] = useState(null);
  const [collapsedAnswers, setCollapsedAnswers] = useState({});
  const [isFileShown, setIsFileShown] = useState(false);
  const [isShareModalOpen, setIsShareModalOpen] = useState(false);
  const [isChatbotShown, setIsChatbotShown] = useState(false);
  const [editMode, setEditMode] = useState(false);
  const [isDiscardEditsDialogOpen, setIsDiscardEditsDialogOpen] =
    useState(false);
  const [topicToDelete, setTopicToDelete] = useState(null);
  const [isDeleteTopicDialogOpen, setIsDeleteTopicDialogOpen] = useState(false);
  const [isDeleteSectionDialogOpen, setIsDeleteSectionDialogOpen] =
    useState(false);
  const [sectionToDelete, setSectionToDelete] = useState(null);
  const [isAddTopicModalOpen, setIsAddTopicModalOpen] = useState(false);
  const topicRefs = useRef({});
  const { currentUser, loadingUser, hasSpark } = useStateContext();
  const [isAutoGenerateDialogOpen, setIsAutoGenerateDialogOpen] =
    useState(false);
  const [autoGenerateSection, setAutoGenerateSection] = useState(null);
  const [topicForAutoGenerate, setTopicForAutoGenerate] = useState(null);
  const theme = useTheme();

  // Check URL to see if the user came from the find study guides page
  const searchParams = useSearchParams();
  const fromSearch = searchParams.get("fromSearch");
  const searchQuery = searchParams.get("searchQuery");

  // Handle the browser back button
  useEffect(() => {
    const handlePopState = (event) => {
      // Only if the back button is clicked trigger the redirect
      if (event.state !== null && fromSearch) {
        router.push(`/find-slides?searchQuery=${searchQuery}`);
      }
    };

    window.addEventListener("popstate", handlePopState);

    return () => {
      window.removeEventListener("popstate", handlePopState);
    };
  }, [fromSearch, searchQuery, router]);

  // When navigating to the study guide page (on mount), clear the chatbot messages
  useEffect(() => {
    localStorage.removeItem("chatbotMessages");
  }, []);

  // Fetch the study guide data from Firestore
  const {
    studyGuide,
    setStudyGuide,
    fileName,
    setFileName,
    hasFlashCards,
    setHasFlashCards,
    hasFirebaseUrl,
    setHasFirebaseUrl,
  } = useFetchStudyGuide(id, currentUser, loadingUser);

  // Use the custom hook for Intersection Observer logic
  useActiveTopic(topicRefs, setActiveTopic, [studyGuide]);

  // Handle the flashcard modal and viewer
  const {
    isFlashcardModalOpen,
    flashcards,
    showFlashcards,
    handleFlashcardClick,
    closeFlashcardModal,
    closeFlashcards,
    swapFlashcardViews,
    handleFlashcardChange,
    handleFlashcardsCreated,
  } = useFlashcards(id, hasSpark, hasFlashCards, setHasFlashCards);

  // Get the device width
  const deviceWidth = useDeviceWidth();

  // Handle the drag and drop functionality
  const handleDragEnd = useDragAndDrop(studyGuide, setStudyGuide);

  // Function to handle opening the share modal
  const handleShareClick = () => {
    setIsShareModalOpen(true);
  };

  // Function to close the share modal
  const closeShareModal = () => {
    setIsShareModalOpen(false);
  };

  // Save the extracted data to Firestore when the user changes it
  const updateStudyGuideOnFirestore = () => {
    if (studyGuide) {
      // Ensure that the extracted data is a string before saving it to Firestore
      const extractedData = JSON.stringify(studyGuide.extractedData);
      updateStudyGuideExtractedData(studyGuide.id, extractedData);

      // Save the hidden explanations to Firestore
      const hiddenExplanations = JSON.stringify(studyGuide.hiddenExplanations);
      updateStudyGuideHiddenExplanations(studyGuide.id, hiddenExplanations);
    }
  };

  if (!studyGuide) {
    return <></>;
  }

  let content;
  if (hasFirebaseUrl) {
    // Split off the query string from the Firebase file URL
    const baseFileUrl = studyGuide.firebaseFileUrl.split("?")[0];

    // Get the file extension from the base URL
    const fileExtension = baseFileUrl.split(".").pop().toLowerCase();

    // Set the viewer URL to the Firebase file URL by default, but if it's a PowerPoint file, use the Google Drive viewer
    let viewerUrl = studyGuide.firebaseFileUrl;
    if (fileExtension === "pptx") {
      viewerUrl = getViewerUrl(studyGuide.firebaseFileUrl);
    }

    // Set the content to be an iframe with the viewer URL
    content = (
      <iframe
        src={viewerUrl}
        style={{
          border: "none",
          width: "100%",
          height: "80vh",
          transform: "scale(0.95)",
          transformOrigin: "0 0",
        }}
      />
    );
  }

  // Function to toggle if a practice problem answer is collapsed or not
  const toggleAnswer = (answer) => {
    setCollapsedAnswers((prev) => ({
      ...prev,
      [answer]: !prev[answer],
    }));
  };

  // Function to update the study guide object with the new value
  const updateStudyGuideObject = (topic, key, value) => {
    setStudyGuide((prev) => {
      const updatedData = {
        ...prev,
        extractedData: {
          ...prev.extractedData,
          [topic]: {
            ...prev.extractedData[topic],
            [key]: value,
          },
        },
      };
      return updatedData;
    });
  };

  // Function to handle when the user clicks the edit mode option in the menu
  const handleEditClicked = () => {
    if (editMode) {
      // Save the extracted data and hidden explanantions to Firestore when the user changes it
      updateStudyGuideOnFirestore();
      toast.info("Your changes have been saved successfully!");
    } else {
      // Doing this ensures that initialStudyGuide and studyGuide point to different objects in memory
      // This is called a deep copy
      setInitialStudyGuide(JSON.parse(JSON.stringify(studyGuide)));
      toast.info(
        "Edit mode enabled. You can now edit the study guide. Don't forget to save your changes!"
      );
    }
    setEditMode(!editMode);
  };

  // Function to handle discarding edits
  const discardEdits = () => {
    setStudyGuide({ ...initialStudyGuide });
    setEditMode(false);
    toast.info("Edits have been discarded!");
  };

  // Function to delete a topic from the study guide
  const handleTopicDelete = (topic) => {
    // Update the study guide extracted data and hidden explanations to remove the topic
    const updatedData = { ...studyGuide };
    delete updatedData.extractedData[topic];
    delete updatedData.hiddenExplanations[topic];

    setStudyGuide(updatedData);
  };

  // Function to delete a sub section of a topic in the study guide
  const handleDeleteSection = (topic, section) => {
    if (section === "question") {
      const updatedData = { ...studyGuide };
      delete updatedData.extractedData[topic]["question"];
      delete updatedData.extractedData[topic]["answer"];
      setStudyGuide(updatedData);
    } else {
      const updatedData = { ...studyGuide };
      delete updatedData.extractedData[topic][section];
      setStudyGuide(updatedData);
    }
  };

  // Function to add a new topic to the study guide
  const handleAddTopic = (topicName, explanation, autoToggle) => {
    if (studyGuide.extractedData[topicName]) {
      toast.error("Topic already exists. Please choose a different name.");
      return;
    } else if (topicName.length < 1) {
      toast.error("Topic name cannot be empty. Please enter a valid name.");
      return;
    }

    const hiddenExplanations = {
      ...studyGuide.hiddenExplanations,
      [topicName]: explanation,
    };

    // Update the study guide with the new topic
    setStudyGuide((prev) => {
      const updatedData = {
        ...prev,
        extractedData: {
          ...prev.extractedData,
          [topicName]: {
            explanation: explanation,
            youtubeIds: [],
            example: "Fill in the example here...",
            question: "Fill in the question here...",
            answer: "Fill in the answer here...",
          },
        },
        hiddenExplanations: {
          ...prev.hiddenExplanations,
          [topicName]: explanation,
        },
      };
      return updatedData;
    });

    // If autoToggle option is selected, generate the explanation, video, example, and question/answer
    if (autoToggle) {
      handleGenerateExplanation(topicName, hiddenExplanations);
      handleGenerateExample(topicName, hiddenExplanations);
      handleGenerateQuestionAnswer(topicName, hiddenExplanations);
    }
  };

  const handleChatbotToggle = () => {
    setIsChatbotShown(!isChatbotShown);
  };

  const handleFileToggle = () => {
    setIsFileShown(!isFileShown);
  };

  // Handle user saving the study guide
  const saveStudyGuide = async () => {
    if (!hasSpark) {
      toast.error(
        "You need to upgrade to the Spark Plan to save this study guide."
      );
      return;
    }
    let studyGuideClone = {
      fileName: studyGuide.fileName,
      extractedData: JSON.stringify(studyGuide.extractedData),
      topics: Object.keys(studyGuide.extractedData),
      hiddenExplanations: JSON.stringify(studyGuide.hiddenExplanations),
      googleSearchResults: JSON.stringify(studyGuide.googleSearchResults),
      firebaseFileUrl: null,
      createdAt: new Date(),
      lastModified: new Date(),
      createdBy: currentUser.uid,
      contributors: [currentUser.uid],
      editors: [currentUser.uid],
      isPublic: false,
      gotFromPublic: true,
      hasFlashCards: false,
    };

    const studyGuideId = await uploadStudyGuideToFirebase(studyGuideClone);

    if (studyGuideId !== null) {
      router.push(`/study/${studyGuideId}`);
    }
  };

  // Generate a new explanation for a topic
  const handleGenerateExplanation = async (topic, hiddenExplanations) => {
    const text = await generateExplanation(
      topic,
      hiddenExplanations ? hiddenExplanations : studyGuide.hiddenExplanations
    );
    updateStudyGuideObject(topic, "explanation", text);
  };

  // Generate a new example for a topic
  const handleGenerateExample = async (topic, hiddenExplanations) => {
    const text = await generateExample(
      topic,
      hiddenExplanations ? hiddenExplanations : studyGuide.hiddenExplanations
    );
    updateStudyGuideObject(topic, "example", text);
  };

  // Generate a new question and answer for a topic
  const handleGenerateQuestionAnswer = async (topic, hiddenExplanations) => {
    const text = await generateQuestionAnswer(
      topic,
      hiddenExplanations ? hiddenExplanations : studyGuide.hiddenExplanations
    );
    const question = text["question"];
    const answer = text["answer"];
    updateStudyGuideObject(topic, "question", question);
    updateStudyGuideObject(topic, "answer", answer);
  };

  // This is an object that contains the common props for the TopicSection component to avoid repetition
  const commonTopicSectionProps = {
    editMode,
    setAutoGenerateSection,
    setTopicForAutoGenerate,
    setIsAutoGenerateDialogOpen,
    setTopicToDelete,
    setSectionToDelete,
    setIsDeleteSectionDialogOpen,
    updateStudyGuideObject,
  };

  return (
    <StudyGuideContainer>
      <OutputSection>
        {deviceWidth > 768 && (
          <Sidebar
            studyGuideId={studyGuide.id}
            creator={studyGuide.createdBy}
            topics={Object.keys(studyGuide.extractedData)}
            editMode={editMode}
            onDragEnd={handleDragEnd}
            setIsAddTopicModalOpen={setIsAddTopicModalOpen}
            activeTopic={activeTopic}
            fileName={fileName}
            setFileName={setFileName}
            handleEditClicked={handleEditClicked}
            handleShareClick={handleShareClick}
            handleChatbotToggle={handleChatbotToggle}
            isChatbotShown={isChatbotShown}
            handleFileToggle={handleFileToggle}
            isFileShown={isFileShown}
            hasFirebaseUrl={hasFirebaseUrl}
            handleFlashcardClick={handleFlashcardClick}
            fromSearch={fromSearch}
            searchQuery={searchQuery}
            saveStudyGuide={saveStudyGuide}
            contributors={studyGuide.contributors}
            setIsDiscardEditsDialogOpen={setIsDiscardEditsDialogOpen}
            editors={studyGuide.editors}
          />
        )}
        <InfoContainer>
          {studyGuide.extractedData &&
            Object.keys(studyGuide.extractedData).map((key) => (
              <TopicWrapper key={key} id={key}>
                <TopicHeaderContainer
                  id={key}
                  ref={(el) => (topicRefs.current[key] = el)}
                >
                  <TopicHeaderTitle>{key.toUpperCase()}</TopicHeaderTitle>
                  {editMode && (
                    <IconButton
                      icon={<X size={20} />}
                      onClick={() => {
                        setTopicToDelete(key);
                        setIsDeleteTopicDialogOpen(true);
                      }}
                      title="Delete Topic"
                    />
                  )}
                </TopicHeaderContainer>
                {(studyGuide.extractedData[key]["explanation"] ||
                  studyGuide.extractedData[key]["explanation"] === "") && (
                  <TopicSection
                    sectionName={"Explanation"}
                    topic={key}
                    sectionText={studyGuide?.extractedData[key]["explanation"]}
                    {...commonTopicSectionProps}
                  />
                )}
                {(studyGuide.extractedData[key]["example"] ||
                  studyGuide.extractedData[key]["example"] === "") && (
                  <TopicSection
                    sectionName={"Example"}
                    topic={key}
                    sectionText={studyGuide?.extractedData[key]["example"]}
                    {...commonTopicSectionProps}
                  />
                )}
                {studyGuide.extractedData[key]["youtubeIds"] && (
                  <Video
                    topic={key}
                    studyGuide={studyGuide}
                    editMode={editMode}
                    hasSpark={hasSpark}
                    setTopicToDelete={setTopicToDelete}
                    setSectionToDelete={setSectionToDelete}
                    setIsDeleteSectionDialogOpen={setIsDeleteSectionDialogOpen}
                  />
                )}
                {(studyGuide.extractedData[key]["question"] ||
                  studyGuide.extractedData[key]["question"] === "") && (
                  <TopicSection
                    sectionName={"Question"}
                    topic={key}
                    sectionText={studyGuide?.extractedData[key]["question"]}
                    {...commonTopicSectionProps}
                  />
                )}
                {(studyGuide.extractedData[key]["answer"] ||
                  studyGuide.extractedData[key]["answer"] === "") && (
                  <TopicSection
                    sectionName={"Answer"}
                    topic={key}
                    sectionText={studyGuide?.extractedData[key]["answer"]}
                    toggleAnswer={toggleAnswer}
                    collapsedAnswers={collapsedAnswers}
                    {...commonTopicSectionProps}
                  />
                )}
                {editMode && (
                  <AddSectionsContainer
                    topicInfo={studyGuide.extractedData[key]}
                    handleAddSection={(section) => {
                      updateStudyGuideObject(
                        key,
                        section,
                        section === "youtubeIds"
                          ? []
                          : `Fill in the ${section} here or click the magic wand above to auto-generate one...`
                      );
                    }}
                  />
                )}
              </TopicWrapper>
            ))}
          {studyGuide.googleSearchResults.length > 0 && (
            <TopicWrapper>
              <TopicHeaderContainer>
                <TopicHeaderTitle>Extra Resources</TopicHeaderTitle>
              </TopicHeaderContainer>
              <>
                {studyGuide.googleSearchResults.map((search) => {
                  return (
                    <div key={search.title}>
                      <Link href={search.link} target="_blank">
                        {search.title}
                      </Link>
                    </div>
                  );
                })}
              </>
            </TopicWrapper>
          )}
        </InfoContainer>
        {isFileShown && <FileContainer>{content}</FileContainer>}
        <ChatbotContainer $isChatbotShown={isChatbotShown}>
          <Chatbot
            studyGuide={studyGuide}
            setIsChatbotShown={setIsChatbotShown}
          />
        </ChatbotContainer>
      </OutputSection>
      <ShareModal
        studyGuideId={id}
        isOpen={isShareModalOpen}
        onRequestClose={closeShareModal}
        icon={<Forward color={theme.primary} size={48} />}
      />
      <CreateFlashcardModal
        studyGuideId={id}
        studyGuide={studyGuide.extractedData}
        isOpen={isFlashcardModalOpen}
        onRequestClose={closeFlashcardModal}
        onFlashcardsCreated={handleFlashcardsCreated}
        icon={<Zap color={theme.primary} size={48} />}
      />
      {showFlashcards && flashcards && (
        <FlashcardViewer
          studyGuideId={id}
          flashcards={flashcards}
          isOpen={showFlashcards}
          onRequestClose={closeFlashcards}
          onFlashcardsChanged={handleFlashcardChange}
          swapViews={swapFlashcardViews}
        />
      )}
      <ConfirmationModal
        isOpen={isDiscardEditsDialogOpen}
        onClose={() => setIsDiscardEditsDialogOpen(false)}
        title="Discard Edits"
        text="Are you sure you want to discard all edits?"
        onConfirm={() => {
          setIsDiscardEditsDialogOpen(false);
          discardEdits();
        }}
      />
      <ConfirmationModal
        isOpen={isDeleteTopicDialogOpen}
        onClose={() => setIsDeleteTopicDialogOpen(false)}
        title="Delete Study Guide Topic"
        text={`Are you sure you want to delete this study guide topic?\n\nYou cannot undo this action unless you discard your edits.`}
        onConfirm={() => {
          setIsDeleteTopicDialogOpen(false);
          handleTopicDelete(topicToDelete);
          toast.success("Topic has been deleted successfully.");
        }}
        icon={<Trash2 color={theme.primary} size={48} />}
      />
      <ConfirmationModal
        isOpen={isDeleteSectionDialogOpen}
        onClose={() => setIsDeleteSectionDialogOpen(false)}
        title={`Delete ${
          sectionToDelete === "youtubeIds"
            ? "Video"
            : sectionToDelete?.charAt(0).toUpperCase() +
              sectionToDelete?.slice(1)
        }`}
        text={`Are you sure you want to delete this ${
          sectionToDelete === "youtubeIds"
            ? "video section? This will delete all videos that are currently available by clicking the next button."
            : sectionToDelete + " section?"
        }\n\nYou cannot undo this action unless you discard your edits.`}
        onConfirm={() => {
          setIsDeleteSectionDialogOpen(false);
          handleDeleteSection(topicToDelete, sectionToDelete);
        }}
        icon={<Trash2 color={theme.primary} size={48} />}
      />
      <ConfirmationModal
        isOpen={isAutoGenerateDialogOpen}
        onClose={() => {
          setIsAutoGenerateDialogOpen(false);
        }}
        title={`Auto-Generate ${
          autoGenerateSection?.charAt(0).toUpperCase() +
          autoGenerateSection?.slice(1)
        }`}
        text={
          autoGenerateSection === "question"
            ? `Please confirm you want to auto-generate a Question and an Answer. This will overwrite both the current question and answer!`
            : `Please confirm you want to auto-generate an ${autoGenerateSection}. This will overwrite the current ${autoGenerateSection?.toLowerCase()} for this topic!`
        }
        onConfirm={() => {
          if (!hasSpark) {
            toast.error(
              "You need to have a Spark subscription to use this feature."
            );
            return;
          }
          if (autoGenerateSection === "explanation") {
            handleGenerateExplanation(topicForAutoGenerate);
          } else if (autoGenerateSection === "example") {
            handleGenerateExample(topicForAutoGenerate);
          } else if (autoGenerateSection === "question") {
            handleGenerateQuestionAnswer(topicForAutoGenerate);
          }
        }}
        icon={<Sparkles color={theme.primary} size={48} />}
      />
      <AddTopicModal
        isOpen={isAddTopicModalOpen}
        onClose={() => {
          setIsAddTopicModalOpen(false);
        }}
        onConfirm={handleAddTopic}
      />
    </StudyGuideContainer>
  );
};

export default Study;

const StudyGuideContainer = styled.div`
  display: flex;
  flex-direction: column;
  height: 100vh;
  overflow: hidden;
  color: ${({ theme }) => theme.black};
  background-color: ${({ theme }) => theme.lightGray};
`;

const OutputSection = styled.div`
  display: flex;
  width: 100%;
  height: 100%;
  overflow: hidden;
`;

const FileContainer = styled.div`
  display: flex;
  flex-direction: column;
  flex: 1.75;
  justify-content: center;
  align-items: center;
  overflow: auto;
`;

const TopicHeaderContainer = styled.div`
  display: flex;
  justify-content: center;
  position: relative;
  align-items: center;
  padding: 16px;
`;

const TopicHeaderTitle = styled.div`
  font-size: ${({ theme }) => theme.fontSize.subheading};
  font-weight: bold;
  background-color: ${({ theme }) => theme.primary70};
  padding: 8px;
  border-radius: 10px;
`;

const ChatbotContainer = styled.div`
  display: flex;
  flex: ${({ $isChatbotShown }) => ($isChatbotShown ? "2.5" : "0")};
  overflow: hidden;
  overscroll-behavior: contain;
  position: relative;
  margin-right: 16px;
  margin-top: 16px;
  margin-bottom: 12px;
`;
