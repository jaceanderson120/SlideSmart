import { useRouter } from "next/router";
import { useEffect, useRef, useState } from "react";
import styled, { css } from "styled-components";
import Link from "next/link";
import ShareModal from "@/components/ShareModal";
import {
  fetchStudyGuide,
  updateStudyGuideFileName,
  updateStudyGuideExtractedData,
  hasAccessToStudyGuide,
  uploadStudyGuideToFirebase,
  updateStudyGuideHiddenExplanations,
} from "@/firebase/database";
import { FontAwesomeIcon } from "@fortawesome/react-fontawesome";
// The following import prevents a Font Awesome icon server-side rendering bug,
// where the icons flash from a very large icon down to a properly sized one:
import "@fortawesome/fontawesome-svg-core/styles.css";
// Prevent fontawesome from adding its CSS since we did it manually above:
import { config } from "@fortawesome/fontawesome-svg-core";
config.autoAddCss = false; /* eslint-disable import/first */
import {
  faEllipsisVertical,
  faPencil,
  faX,
  faRotateLeft,
  faArrowRight,
  faArrowLeft,
  faMagicWandSparkles,
  faTrashCan,
  faChevronRight,
} from "@fortawesome/free-solid-svg-icons";
import {
  faShareFromSquare,
  faMessage,
} from "@fortawesome/free-regular-svg-icons";
import { useStateContext } from "@/context/StateContext";
import Chatbot from "@/components/Chatbot";
import AutoResizeTextArea from "@/components/AutoResizeTextArea";
import { toast } from "react-toastify";
import { fontSize } from "@/constants/fontSize";
import CustomMenu from "@/components/CustomMenu";
import Button from "@/components/Button";
import ConfirmationDialog from "@/components/ConfirmationDialog";
import AddSectionsContainer from "@/components/AddSectionsContainer";
import AddTopicDialog from "@/components/AddTopicDialog";
import { Dots } from "react-activity";
import "react-activity/dist/library.css";
import { colors } from "@/constants/colors";
import {
  generateExample,
  generateExplanation,
  generateQuestionAnswer,
} from "@/utils/generateStudyGuideSections";
import StudyGuideTopics from "@/components/StudyGuideTopics";
import Navbar from "@/components/Navbar";

function getViewerUrl(url) {
  const viewerUrl = `https://drive.google.com/viewerng/viewer?embedded=true&url=${encodeURIComponent(
    url
  )}`;
  return viewerUrl;
}

const Study = () => {
  const router = useRouter();
  const { id } = router.query;
  const [initialStudyGuide, setInitialStudyGuide] = useState(null);
  const [studyGuide, setStudyGuide] = useState(null);
  const [activeTopic, setActiveTopic] = useState(null);
  const [collapsedAnswers, setCollapsedAnswers] = useState({});
  const [isTopicsShown, setIsTopicsShown] = useState(true);
  const [isFileShown, setIsFileShown] = useState(false);
  const [isShareModalOpen, setIsShareModalOpen] = useState(false);
  const [isChatbotShown, setIsChatbotShown] = useState(false);
  const [fileName, setFileName] = useState("");
  const [editMode, setEditMode] = useState(false);
  const [isDiscardEditsDialogOpen, setIsDiscardEditsDialogOpen] =
    useState(false);
  const [topicToDelete, setTopicToDelete] = useState(null);
  const [isDeleteTopicDialogOpen, setIsDeleteTopicDialogOpen] = useState(false);
  const [isDeleteSubSectionDialogOpen, setIsDeleteSubSectionDialogOpen] =
    useState(false);
  const [subSectionToDelete, setSubSectionToDelete] = useState(null);
  const [isAddTopicDialogOpen, setIsAddTopicDialogOpen] = useState(false);
  const [isNewYoutubeVideoDialogOpen, setIsNewYoutubeVideoDialogOpen] =
    useState(false);
  const [topicForNewYoutubeVideo, setTopicForNewYoutubeVideo] = useState(null);
  const [findingNewYoutubeVideo, setfindingNewYoutubeVideo] = useState(false);
  const [videoIndices, setVideoIndices] = useState([]);
  const topicRefs = useRef({});
  const titleInputRef = useRef(null);
  const { currentUser, loadingUser, hasSpark } = useStateContext();
  const [hasFirebaseUrl, setHasFirebaseUrl] = useState(false);
  const [isAutoGenerateDialogOpen, setIsAutoGenerateDialogOpen] =
    useState(false);
  const [autoGenerateSection, setAutoGenerateSection] = useState(null);
  const [topicForAutoGenerate, setTopicForAutoGenerate] = useState(null);

  // When navigating to the study guide page (on mount), clear the chatbot messages
  useEffect(() => {
    localStorage.removeItem("chatbotMessages");
  }, []);

  useEffect(() => {
    const checkAccessAndFetchData = async () => {
      // If the state context is still loadingUser, wait for it to finish
      if (loadingUser) {
        return;
      }

      // If the user is not logged in, redirect them to the login page
      if (!currentUser) {
        router.push("/login");
        return;
      }

      // If the user is logged in, check if they have access to the study guide
      if (id && currentUser) {
        const hasAccess = await hasAccessToStudyGuide(id, currentUser.uid);

        // If the user has access to the study guide, fetch the study guide data
        const { fetchedStudyGuide, fileName } = await fetchStudyGuide(id);

        // If the user does not have access to the study guide AND the study guide is private, redirect them to their study guides page
        if (!hasAccess && !fetchedStudyGuide.isPublic) {
          router.push(`/dashboard`);
          return;
        }

        // Set the study guide and file name
        setStudyGuide(fetchedStudyGuide);
        setFileName(fileName);

        // Check if fetchedStudyGuide has firebaseFileUrl
        if (fetchedStudyGuide.firebaseFileUrl) {
          setHasFirebaseUrl(true);
        } else {
          setHasFirebaseUrl(false);
        }

        // Set the youtube indices to zeros for each topic
        const indices = {};
        Object.keys(fetchedStudyGuide.extractedData).forEach((key) => {
          indices[key] = 0;
        });
        setVideoIndices(indices);
      }
    };

    checkAccessAndFetchData();
  }, [id, currentUser, router, loadingUser]);

  // Function to handle opening the share modal
  const handleShareClick = () => {
    setIsShareModalOpen(true);
  };

  // Function to close the share modal
  const closeShareModal = () => {
    setIsShareModalOpen(false);
  };

  // Update the file name that is displayed at the top of the study guide
  const handleFileNameChange = (e) => {
    setFileName(e.target.value);
  };

  // Save the file name to Firestore when the input field is blurred
  const handleFileNameSave = async () => {
    if (studyGuide) {
      if (fileName.length < 1) {
        setFileName("Untitled Study Guide");
        updateStudyGuideFileName(studyGuide.id, "Untitled Study Guide");
      } else {
        updateStudyGuideFileName(studyGuide.id, fileName);
      }
    }
  };

  // Handle pressing Enter key to blur the title input field
  const handleKeyDown = (e) => {
    if (e.key === "Enter") {
      titleInputRef.current.blur();
    }
  };

  // Save the extracted data to Firestore when the user changes it
  const updateStudyGuideOnFirestore = () => {
    if (studyGuide) {
      // Ensure that the extracted data is a string before saving it to Firestore
      const extractedData = JSON.stringify(studyGuide.extractedData);
      updateStudyGuideExtractedData(studyGuide.id, extractedData);

      // Save the hidden explanations to Firestore
      const hiddenExplanations = JSON.stringify(studyGuide.hiddenExplanations);
      updateStudyGuideHiddenExplanations(studyGuide.id, hiddenExplanations);
    }
  };

  useEffect(() => {
    // When 100% of a topic title is in view, set it as the active topic by calling the callback function
    const observer = new IntersectionObserver(
      (entries) => {
        entries.forEach((entry) => {
          if (entry.isIntersecting) {
            setActiveTopic(entry.target.id);
          }
        });
      },
      {
        threshold: 1,
        rootMargin: "0px",
      }
    );

    Object.keys(topicRefs.current).forEach((key) => {
      if (topicRefs.current[key]) {
        observer.observe(topicRefs.current[key]);
      }
    });

    return () => {
      Object.keys(topicRefs.current).forEach((key) => {
        if (topicRefs.current[key]) {
          observer.unobserve(topicRefs.current[key]);
        }
      });
    };
  }, [studyGuide]);

  if (!studyGuide) {
    return <></>;
  }

  let content;
  if (hasFirebaseUrl) {
    // Split off the query string from the Firebase file URL
    const baseFileUrl = studyGuide.firebaseFileUrl.split("?")[0];

    // Get the file extension from the base URL
    const fileExtension = baseFileUrl.split(".").pop().toLowerCase();

    // Set the viewer URL to the Firebase file URL by default, but if it's a PowerPoint file, use the Google Drive viewer
    let viewerUrl = studyGuide.firebaseFileUrl;
    if (fileExtension === "pptx") {
      viewerUrl = getViewerUrl(studyGuide.firebaseFileUrl);
    }

    // Set the content to be an iframe with the viewer URL
    content = (
      <iframe
        src={viewerUrl}
        style={{
          border: "none",
          width: "100%",
          height: "80vh",
          transform: "scale(0.95)",
          transformOrigin: "0 0",
        }}
      />
    );
  }

  // Function to toggle if a practice problem answer is collapsed or not
  const toggleAnswer = (answer) => {
    setCollapsedAnswers((prev) => ({
      ...prev,
      [answer]: !prev[answer],
    }));
  };

  // Function to update the study guide object with the new value
  const updateStudyGuideObject = (topic, key, value) => {
    setStudyGuide((prev) => {
      const updatedData = {
        ...prev,
        extractedData: {
          ...prev.extractedData,
          [topic]: {
            ...prev.extractedData[topic],
            [key]: value,
          },
        },
      };
      return updatedData;
    });
  };

  // Function to handle when the user clicks the edit mode option in the menu
  const handleEditClicked = () => {
    if (editMode) {
      // Save the extracted data and hidden explanantions to Firestore when the user changes it
      updateStudyGuideOnFirestore();
      toast.info(
        "Edit Mode has been disabled. Your study guide has been saved successfully!"
      );
    } else {
      // Doing this ensures that initialStudyGuide and studyGuide point to different objects in memory
      // This is called a deep copy
      setInitialStudyGuide(JSON.parse(JSON.stringify(studyGuide)));
      toast.info(
        "Edit Mode has been enabled. Make your changes and disable Edit Mode to save!"
      );
    }
    setEditMode(!editMode);
  };

  // Function to handle discarding edits
  const discardEdits = () => {
    setStudyGuide({ ...initialStudyGuide });
    setEditMode(false);
    toast.info("Edits have been discarded!");
  };

  // Function to delete a topic from the study guide
  const handleTopicDelete = (topic) => {
    // Update the study guide extracted data and hidden explanations to remove the topic
    const updatedData = { ...studyGuide };
    delete updatedData.extractedData[topic];
    delete updatedData.hiddenExplanations[topic];

    setStudyGuide(updatedData);
  };

  // Function to delete a sub section of a topic in the study guide
  const handleDeleteSubSection = (topic, subSection) => {
    if (subSection === "Q/A") {
      const updatedData = { ...studyGuide };
      delete updatedData.extractedData[topic]["question"];
      delete updatedData.extractedData[topic]["answer"];
      setStudyGuide(updatedData);
    } else {
      const updatedData = { ...studyGuide };
      delete updatedData.extractedData[topic][subSection];
      setStudyGuide(updatedData);
    }
  };

  // Function to add a new topic to the study guide
  const handleAddTopic = (topicName, explanation) => {
    if (studyGuide.extractedData[topicName]) {
      toast.error("Topic already exists. Please choose a different name.");
      return;
    } else if (topicName.length < 1) {
      toast.error("Topic name cannot be empty. Please enter a valid name.");
      return;
    }

    setStudyGuide((prev) => {
      const updatedData = {
        ...prev,
        extractedData: {
          ...prev.extractedData,
          [topicName]: {
            explanation: explanation,
            youtubeIds: "None",
            example: "Fill in the example here...",
            question: "Fill in the question here...",
            answer: "Fill in the answer here...",
          },
        },
        hiddenExplanations: {
          ...prev.hiddenExplanations,
          [topicName]: explanation,
        },
      };
      return updatedData;
    });
  };

  // Function to reorder the keys of studyGuide.extractedData
  const reorderExtractedData = (order) => {
    setStudyGuide((prev) => {
      const reorderedData = {};
      order.forEach((key) => {
        if (prev.extractedData[key]) {
          reorderedData[key] = prev.extractedData[key];
        }
      });
      return {
        ...prev,
        extractedData: reorderedData,
      };
    });
  };

  // Handle drag end
  const handleDragEnd = (result) => {
    if (!result.destination) {
      return;
    }

    const items = Array.from(Object.keys(studyGuide.extractedData));
    const [reorderedItem] = items.splice(result.source.index, 1);
    items.splice(result.destination.index, 0, reorderedItem);

    reorderExtractedData(items);
  };

  const handleTopicToggle = () => {
    setIsTopicsShown(!isTopicsShown);
  };

  const handleChatbotToggle = () => {
    // Collapse topics and file when chatbot is shown
    if (!isChatbotShown) {
      setIsTopicsShown(false);
      setIsFileShown(false);
    }
    setIsChatbotShown(!isChatbotShown);
  };

  const handleFileToggle = () => {
    setIsFileShown(!isFileShown);
    setIsTopicsShown(false);
  };

  // Menu items for the study guide page
  let menuItems;
  if (hasFirebaseUrl) {
    menuItems = [
      {
        name: isTopicsShown ? "Collapse Topics" : "Show Topics",
        onClick: handleTopicToggle,
      },
      {
        name: isFileShown ? "Collapse File" : "Show File",
        onClick: handleFileToggle,
      },
    ];
  } else {
    menuItems = [
      {
        name: isTopicsShown ? "Collapse Topics" : "Show Topics",
        onClick: handleTopicToggle,
      },
    ];
  }

  // Get a new YouTube video
  const getNewYoutubeVideo = async (topic, data) => {
    setfindingNewYoutubeVideo(true);

    // Filter the data to only be the topic name and explanation
    const filteredData = {
      topic: topic,
      explanation: data?.explanation,
    };

    const res = await fetch("/api/create-youtube-query", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify(filteredData), // Sending the topic as JSON
    });
    const query = await res.json();

    const res2 = await fetch("/api/get-youtube-video", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({ query }), // Sending the topic as JSON
    });
    const videoId = await res2.json();

    // Update the study guide object with the new YouTube video ID
    updateStudyGuideObject(topic, "youtubeIds", videoId);
    setfindingNewYoutubeVideo(false);
  };

  // Function to go to previous video
  const goToPreviousVideo = (topic) => {
    if (videoIndices[topic] > 0) {
      setVideoIndices((prev) => ({
        ...prev,
        [topic]: prev[topic] - 1,
      }));
    } else {
      setVideoIndices((prev) => ({
        ...prev,
        [topic]: studyGuide.extractedData[topic]["youtubeIds"].length - 1,
      }));
    }
  };

  // Function to go to next video
  const goToNextVideo = (topic) => {
    if (
      videoIndices[topic] <
      studyGuide.extractedData[topic]["youtubeIds"].length - 1
    ) {
      setVideoIndices((prev) => ({
        ...prev,
        [topic]: prev[topic] + 1,
      }));
    } else {
      setVideoIndices((prev) => ({
        ...prev,
        [topic]: 0,
      }));
    }
  };

  // Handle user saving the study guide
  const saveStudyGuide = async () => {
    if (!hasSpark) {
      toast.error(
        "You need to upgrade to the Spark Plan to save this study guide."
      );
      return;
    }
    let studyGuideClone = {
      fileName: studyGuide.fileName,
      extractedData: JSON.stringify(studyGuide.extractedData),
      hiddenExplanations: JSON.stringify(studyGuide.hiddenExplanations),
      googleSearchResults: JSON.stringify(studyGuide.googleSearchResults),
      firebaseFileUrl: null,
      createdAt: new Date(),
      createdBy: currentUser.uid,
      contributors: [currentUser.uid],
      editors: [currentUser.uid],
      isPublic: false,
      gotFromPublic: true,
    };

    const studyGuideId = await uploadStudyGuideToFirebase(studyGuideClone);

    if (studyGuideId !== null) {
      router.push(`/study/${studyGuideId}`);
    }
  };

  // Generate a new explanation for a topic
  const handleGenerateExplanation = async (topic) => {
    const text = await generateExplanation(
      topic,
      studyGuide.hiddenExplanations
    );
    updateStudyGuideObject(topic, "explanation", text);
  };

  // Generate a new example for a topic
  const handleGenerateExample = async (topic) => {
    const text = await generateExample(topic, studyGuide.hiddenExplanations);
    updateStudyGuideObject(topic, "example", text);
  };

  // Generate a new question and answer for a topic
  const handleGenerateQuestionAnswer = async (topic) => {
    const text = await generateQuestionAnswer(
      topic,
      studyGuide.hiddenExplanations
    );
    const question = text["question"];
    const answer = text["answer"];
    updateStudyGuideObject(topic, "question", question);
    updateStudyGuideObject(topic, "answer", answer);
  };

  return (
    <PageContainer>
      <Section>
        <HeaderSection>
          <BackToDashboardContainer>
            <Button
              onClick={() => {
                router.push("/dashboard");
              }}
              padding="0px"
              backgroundColor="transparent"
              hoverBackgroundColor="transparent"
            >
              <FontAwesomeIcon icon={faArrowLeft} size="lg" /> Back to Dashboard
            </Button>
          </BackToDashboardContainer>
          <Title
            type="text"
            value={fileName}
            onChange={handleFileNameChange}
            onBlur={handleFileNameSave}
            onKeyDown={handleKeyDown}
            ref={titleInputRef}
            readOnly={
              editMode && studyGuide.editors.includes(currentUser?.uid)
                ? false
                : true
            }
            $editMode={editMode}
          />
          <MenuTriggerArea>
            {editMode && (
              <>
                <Button
                  backgroundColor="transparent"
                  hoverBackgroundColor="transparent"
                  textColor={colors.black}
                  hoverTextColor={colors.white}
                  onClick={handleEditClicked}
                  padding="4px"
                  bold
                >
                  Save
                </Button>
                <Button
                  backgroundColor="transparent"
                  hoverBackgroundColor="transparent"
                  textColor={colors.black}
                  hoverTextColor={colors.white}
                  onClick={() => setIsDiscardEditsDialogOpen(true)}
                  padding="4px"
                  bold
                >
                  Discard
                </Button>
              </>
            )}
            {!editMode && (
              <>
                {studyGuide.editors.includes(currentUser?.uid) && (
                  <StyledFontAwesomeIcon
                    icon={faPencil}
                    size="xl"
                    title="Edit"
                    onClick={handleEditClicked}
                  />
                )}
              </>
            )}
            {studyGuide.createdBy === currentUser?.uid && (
              <StyledFontAwesomeIcon
                icon={faShareFromSquare}
                size="xl"
                title="Share"
                onClick={handleShareClick}
              />
            )}
            {studyGuide.isPublic &&
              !studyGuide.contributors.includes(currentUser?.uid) && (
                <Button onClick={saveStudyGuide}>Save File</Button>
              )}
            <StyledFontAwesomeIcon
              icon={faMessage}
              size="xl"
              title="Sola"
              onClick={handleChatbotToggle}
            />
            <CustomMenu
              triggerElement={
                <StyledFontAwesomeIcon
                  icon={faEllipsisVertical}
                  size="xl"
                  title="Menu"
                />
              }
              menuItems={menuItems}
            />
          </MenuTriggerArea>
        </HeaderSection>
        <OutputSection>
          <StudyGuideTopics
            topics={Object.keys(studyGuide.extractedData)}
            editMode={editMode}
            onDragEnd={handleDragEnd}
            setIsAddTopicDialogOpen={setIsAddTopicDialogOpen}
            activeTopic={activeTopic}
            isTopicsShown={isTopicsShown}
            flex={isTopicsShown ? "0.5" : "0"}
          />
          <InfoContainer id="infoContainer">
            {studyGuide.extractedData &&
              Object.keys(studyGuide.extractedData).map((key) => (
                <InfoSubContainer key={key} id={key}>
                  <TopicHeaderContainer
                    id={key}
                    ref={(el) => (topicRefs.current[key] = el)}
                  >
                    <TopicHeaderTitle>{key.toUpperCase()}</TopicHeaderTitle>
                    {editMode && (
                      <StyledFontAwesomeIcon
                        icon={faTrashCan}
                        size="lg"
                        title="Delete Topic"
                        onClick={() => {
                          setTopicToDelete(key);
                          setIsDeleteTopicDialogOpen(true);
                        }}
                      />
                    )}
                  </TopicHeaderContainer>
                  {(studyGuide.extractedData[key]["explanation"] ||
                    studyGuide.extractedData[key]["explanation"] === "") && (
                    <TopicSubContainer>
                      <TopicSubsectionHeader>
                        Explanation:
                        {editMode && (
                          <div>
                            <StyledFontAwesomeIcon
                              icon={faMagicWandSparkles}
                              onClick={() => {
                                setAutoGenerateSection("Explanation");
                                setTopicForAutoGenerate(key);
                                setIsAutoGenerateDialogOpen(true);
                              }}
                              title="Generate Explanation"
                            />
                            <StyledFontAwesomeIcon
                              icon={faX}
                              onClick={() => {
                                setTopicToDelete(key);
                                setSubSectionToDelete("explanation");
                                setIsDeleteSubSectionDialogOpen(true);
                              }}
                              title="Delete explanation"
                            />
                          </div>
                        )}
                      </TopicSubsectionHeader>
                      <AutoResizeTextArea
                        key={editMode} // Trigger re-render when edit mode changes
                        onChange={(text) => {
                          updateStudyGuideObject(key, "explanation", text);
                        }}
                        value={studyGuide.extractedData[key]["explanation"]}
                        editMode={editMode}
                      />
                    </TopicSubContainer>
                  )}
                  {(studyGuide.extractedData[key]["example"] ||
                    studyGuide.extractedData[key]["example"] === "") && (
                    <TopicSubContainer>
                      <TopicSubsectionHeader>
                        Example:
                        {editMode && (
                          <div>
                            <StyledFontAwesomeIcon
                              icon={faMagicWandSparkles}
                              onClick={() => {
                                setAutoGenerateSection("Example");
                                setTopicForAutoGenerate(key);
                                setIsAutoGenerateDialogOpen(true);
                              }}
                              title="Generate Example"
                            />
                            <StyledFontAwesomeIcon
                              icon={faX}
                              onClick={() => {
                                setTopicToDelete(key);
                                setSubSectionToDelete("example");
                                setIsDeleteSubSectionDialogOpen(true);
                              }}
                              title="Delete Example"
                            />
                          </div>
                        )}
                      </TopicSubsectionHeader>
                      <AutoResizeTextArea
                        key={editMode} // Trigger re-render when edit mode changes
                        onChange={(text) => {
                          updateStudyGuideObject(key, "example", text);
                        }}
                        value={studyGuide.extractedData[key]["example"]}
                        editMode={editMode}
                      />
                    </TopicSubContainer>
                  )}
                  {studyGuide.extractedData[key]["youtubeIds"] && (
                    <TopicSubVideoContainer>
                      {topicForNewYoutubeVideo === key &&
                      findingNewYoutubeVideo ? (
                        <Dots />
                      ) : studyGuide.extractedData[key]["youtubeIds"] !==
                        "None" ? (
                        <VideoContainer>
                          <iframe
                            width="560"
                            height="315"
                            src={`https://www.youtube.com/embed/${
                              studyGuide.extractedData[key]["youtubeIds"][
                                isNaN(videoIndices[key]) ||
                                videoIndices[key] >=
                                  studyGuide.extractedData[key]["youtubeIds"]
                                    .length
                                  ? 1
                                  : videoIndices[key]
                              ]
                            }`}
                            title="YouTube video player"
                            frameBorder="0"
                            allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
                            allowFullScreen
                          ></iframe>
                          <SwitchVideoContainer>
                            <StyledFontAwesomeIcon
                              icon={faArrowLeft}
                              onClick={() => {
                                goToPreviousVideo(key);
                              }}
                              title="Previous Video"
                            />
                            <span>
                              {isNaN(videoIndices[key])
                                ? 1
                                : videoIndices[key] + 1}{" "}
                              of{" "}
                              {
                                studyGuide.extractedData[key]["youtubeIds"]
                                  .length
                              }
                            </span>
                            <StyledFontAwesomeIcon
                              icon={faArrowRight}
                              onClick={() => {
                                goToNextVideo(key);
                              }}
                              title="Next Video"
                            />
                            <div>
                              {editMode && (
                                <>
                                  <StyledFontAwesomeIcon
                                    icon={faRotateLeft}
                                    onClick={() => {
                                      setTopicForNewYoutubeVideo(key);
                                      setIsNewYoutubeVideoDialogOpen(true);
                                    }}
                                    title="Find New Videos"
                                  />
                                  <StyledFontAwesomeIcon
                                    icon={faX}
                                    onClick={() => {
                                      setTopicToDelete(key);
                                      setSubSectionToDelete("youtubeIds");
                                      setIsDeleteSubSectionDialogOpen(true);
                                    }}
                                    title="Delete Video"
                                  />
                                </>
                              )}
                            </div>
                          </SwitchVideoContainer>
                        </VideoContainer>
                      ) : (
                        <div style={{ display: "flex", alignItems: "center" }}>
                          <NoVideoText>
                            No video available. Please fill in the topic
                            explanation and then generate a video.
                          </NoVideoText>
                          {editMode && (
                            <>
                              <StyledFontAwesomeIcon
                                icon={faRotateLeft}
                                onClick={() => {
                                  setTopicForNewYoutubeVideo(key);
                                  setIsNewYoutubeVideoDialogOpen(true);
                                }}
                                title="Find New Videos"
                              />
                              <StyledFontAwesomeIcon
                                icon={faX}
                                onClick={() => {
                                  setTopicToDelete(key);
                                  setSubSectionToDelete("youtubeIds");
                                  setIsDeleteSubSectionDialogOpen(true);
                                }}
                                title="Delete Video"
                              />
                            </>
                          )}
                        </div>
                      )}
                    </TopicSubVideoContainer>
                  )}
                  {(studyGuide.extractedData[key]["question"] ||
                    studyGuide.extractedData[key]["question"] === "") && (
                    <TopicSubContainer>
                      <TopicSubsectionHeader>
                        Question:
                        {editMode && (
                          <div>
                            <StyledFontAwesomeIcon
                              icon={faMagicWandSparkles}
                              onClick={() => {
                                setAutoGenerateSection("Q/A");
                                setTopicForAutoGenerate(key);
                                setIsAutoGenerateDialogOpen(true);
                              }}
                              title="Generate Question/Answer"
                            />
                            <StyledFontAwesomeIcon
                              icon={faX}
                              onClick={() => {
                                setTopicToDelete(key);
                                setSubSectionToDelete("Q/A");
                                setIsDeleteSubSectionDialogOpen(true);
                              }}
                              title="Delete Q/A"
                            />
                          </div>
                        )}
                      </TopicSubsectionHeader>
                      <AutoResizeTextArea
                        key={editMode} // Trigger re-render when edit mode changes
                        onChange={(text) => {
                          updateStudyGuideObject(key, "question", text);
                        }}
                        value={studyGuide.extractedData[key]["question"]}
                        editMode={editMode}
                      />
                    </TopicSubContainer>
                  )}
                  {(studyGuide.extractedData[key]["answer"] ||
                    studyGuide.extractedData[key]["answer"] === "") && (
                    <TopicSubContainer>
                      <TopicAnswerContainer>
                        <TopicSubsectionHeader>
                          Answer:
                          {!editMode && (
                            <Button
                              onClick={() => toggleAnswer(key)}
                              padding="8px"
                              fontSize={fontSize.label}
                              backgroundColor={colors.primary70}
                              hoverBackgroundColor={colors.primary70}
                              textColor={colors.black}
                              hoverTextColor={colors.white}
                            >
                              {!collapsedAnswers[key] ? "SHOW" : "HIDE"}
                            </Button>
                          )}
                        </TopicSubsectionHeader>
                      </TopicAnswerContainer>
                      {!editMode ? (
                        collapsedAnswers[key] && (
                          <AutoResizeTextArea
                            key={editMode} // Trigger re-render when edit mode changes
                            onChange={(text) => {
                              updateStudyGuideObject(key, "answer", text);
                            }}
                            value={studyGuide.extractedData[key]["answer"]}
                            editMode={editMode}
                          />
                        )
                      ) : (
                        <AutoResizeTextArea
                          key={editMode} // Trigger re-render when edit mode changes
                          onChange={(text) => {
                            updateStudyGuideObject(key, "answer", text);
                          }}
                          value={studyGuide.extractedData[key]["answer"]}
                          editMode={editMode}
                        />
                      )}
                    </TopicSubContainer>
                  )}
                  {editMode && (
                    <AddSectionsContainer
                      topicInfo={studyGuide.extractedData[key]}
                      handleAddSection={(section) => {
                        updateStudyGuideObject(
                          key,
                          section,
                          section === "youtubeIds"
                            ? "None"
                            : `Fill in the ${section} here or click the magic wand above to auto-generate one...`
                        );
                      }}
                    />
                  )}
                </InfoSubContainer>
              ))}
            {studyGuide.googleSearchResults.length > 0 && (
              <InfoSubContainer>
                <TopicHeaderContainer>
                  <TopicHeaderTitle>Extra Resources</TopicHeaderTitle>
                </TopicHeaderContainer>
                <>
                  <TopicSubContainer>
                    {studyGuide.googleSearchResults.map((search) => {
                      return (
                        <div key={search.title}>
                          <Link href={search.link} target="_blank">
                            {search.title}
                          </Link>
                        </div>
                      );
                    })}
                  </TopicSubContainer>
                </>
              </InfoSubContainer>
            )}
          </InfoContainer>
          {isFileShown && <FileContainer>{content}</FileContainer>}
          <ChatbotContainer $isChatbotShown={isChatbotShown}>
            <Chatbot
              studyGuide={studyGuide}
              setIsChatbotShown={setIsChatbotShown}
            />
          </ChatbotContainer>
        </OutputSection>
      </Section>
      <ShareModal
        studyGuideId={id}
        isOpen={isShareModalOpen}
        onRequestClose={closeShareModal}
        icon={
          <FontAwesomeIcon
            icon={faShareFromSquare}
            size="3x"
            color={colors.primary}
          />
        }
      />
      <ConfirmationDialog
        isOpen={isDiscardEditsDialogOpen}
        onClose={() => setIsDiscardEditsDialogOpen(false)}
        title="Discard Edits"
        text="Are you sure you want to discard all edits?"
        onConfirm={() => {
          setIsDiscardEditsDialogOpen(false);
          discardEdits();
        }}
      />
      <ConfirmationDialog
        isOpen={isDeleteTopicDialogOpen}
        onClose={() => setIsDeleteTopicDialogOpen(false)}
        title="Delete Study Guide Topic"
        text={`Are you sure you want to delete this study guide topic?\n\nYou cannot undo this action unless you discard your edits.`}
        onConfirm={() => {
          setIsDeleteTopicDialogOpen(false);
          handleTopicDelete(topicToDelete);
          toast.success("Topic has been deleted successfully.");
        }}
        icon={
          <FontAwesomeIcon icon={faTrashCan} size="3x" color={colors.primary} />
        }
      />
      <ConfirmationDialog
        isOpen={isDeleteSubSectionDialogOpen}
        onClose={() => setIsDeleteSubSectionDialogOpen(false)}
        title={`Delete ${
          subSectionToDelete === "youtubeIds"
            ? "Video"
            : subSectionToDelete?.charAt(0).toUpperCase() +
              subSectionToDelete?.slice(1)
        }`}
        text={`Are you sure you want to delete this ${
          subSectionToDelete === "youtubeIds"
            ? "video? This will delete all videos that are currently available by clicking the next button."
            : subSectionToDelete + "?"
        }\n\nYou cannot undo this action unless you discard your edits.`}
        onConfirm={() => {
          setIsDeleteSubSectionDialogOpen(false);
          handleDeleteSubSection(topicToDelete, subSectionToDelete);
        }}
        icon={
          <FontAwesomeIcon icon={faTrashCan} size="3x" color={colors.primary} />
        }
      />
      <ConfirmationDialog
        isOpen={isNewYoutubeVideoDialogOpen}
        onClose={() => {
          setIsNewYoutubeVideoDialogOpen(false);
        }}
        title="Find More Videos"
        text={`SlideSmart uses AI and complex algorithms to analyze your topic explanation and find the best YouTube videos to help you learn.\n\nIf the same videos appear after regenerating videos, it is because they are the best videos for your explanation.\n\nPlease confirm that your topic explanation reflects what you wish to learn.`}
        onConfirm={() => {
          if (!hasSpark) {
            toast.error(
              "You need to have a Spark subscription to use this feature."
            );
            return;
          }
          setIsNewYoutubeVideoDialogOpen(false);
          getNewYoutubeVideo(
            topicForNewYoutubeVideo,
            studyGuide.extractedData[topicForNewYoutubeVideo]
          );
        }}
      />
      <ConfirmationDialog
        isOpen={isAutoGenerateDialogOpen}
        onClose={() => {
          setIsAutoGenerateDialogOpen(false);
        }}
        title={`Auto-Generate ${autoGenerateSection}`}
        text={
          autoGenerateSection === "Q/A"
            ? `Please confirm you want to auto-generate a Question and an Answer. This will overwrite both the current question and answer!`
            : `Please confirm you want to auto-generate an ${autoGenerateSection}. This will overwrite the current ${autoGenerateSection?.toLowerCase()} for this topic!`
        }
        onConfirm={() => {
          if (!hasSpark) {
            toast.error(
              "You need to have a Spark subscription to use this feature."
            );
            return;
          }
          if (autoGenerateSection === "Explanation") {
            handleGenerateExplanation(topicForAutoGenerate);
          } else if (autoGenerateSection === "Example") {
            handleGenerateExample(topicForAutoGenerate);
          } else if (autoGenerateSection === "Q/A") {
            handleGenerateQuestionAnswer(topicForAutoGenerate);
          }
        }}
        icon={
          <FontAwesomeIcon
            icon={faMagicWandSparkles}
            size="3x"
            color={colors.primary}
          />
        }
      />
      <AddTopicDialog
        isOpen={isAddTopicDialogOpen}
        onClose={() => {
          setIsAddTopicDialogOpen(false);
        }}
        onConfirm={handleAddTopic}
      />
    </PageContainer>
  );
};

export default Study;

const PageContainer = styled.div`
  display: flex;
  flex-direction: column;
  height: 100vh;
  overflow: hidden;
`;

const Section = styled.div`
  display: flex;
  flex-grow: 1;
  flex-direction: column;
  justify-content: flex-start;
  align-items: flex-start;
  text-align: center;
  color: ${colors.black};
  background-color: ${colors.lightGray};
  overflow: hidden;
`;

const Title = styled.input`
  ${({ $editMode }) =>
    $editMode
      ? css`
          background-color: ${colors.white};
        `
      : css`
          background-color: transparent;
        `}
  font-size: ${fontSize.subheading};
  font-weight: bold;
  text-overflow: ellipsis;
  overflow: hidden;
  white-space: nowrap;
  padding: 8px;
  text-align: center;
  width: ${({ value }) => value.length + "ch"};
  min-width: 20%;
  max-width: 40%;
  border: none;
  border-radius: 10px;
`;

const HeaderSection = styled.div`
  display: flex;
  flex-direction: row;
  justify-content: center;
  align-items: center;
  width: 100%;
  background-color: ${colors.primary70};
  box-shadow: 0px 2px 5px rgba(0, 0, 0, 0.2);
  margin-bottom: 16px;
  padding-top: 4px;
  padding-bottom: 4px;
`;

const BackToDashboardContainer = styled.div`
  display: flex;
  align-items: center;
  position: absolute;
  left: 16px;
`;

const MenuTriggerArea = styled.div`
  display: flex;
  flex-direction: row;
  gap: 8px;
  align-items: center;
  position: absolute;
  right: 16px;
`;

const StyledFontAwesomeIcon = styled(FontAwesomeIcon)`
  padding-left: 10px;
  padding-right: 10px;
  &:hover {
    transition: color 0.3s;
    color: ${colors.primary};
    cursor: pointer;
  }
`;

const OutputSection = styled.div`
  display: flex;
  width: 100%;
  overflow: scroll;
`;

const InfoContainer = styled.div`
  display: flex;
  flex: 2.5;
  flex-direction: column;
  width: 100%;
  gap: 16px;
  overflow: scroll;
  padding-right: 16px;
  padding-bottom: 16px;
`;

const FileContainer = styled.div`
  display: flex;
  flex-direction: column;
  flex: 1.75;
  justify-content: center;
  align-items: center;
  overflow: auto;
`;

const InfoSubContainer = styled.div`
  display: flex;
  flex-direction: column;
  align-items: center;
  padding-right: 16px;
  padding-left: 16px;
  padding-bottom: 16px;
  gap: 16px;
  width: 100%;
  background-color: ${colors.white};
  border-radius: 12px;
  box-shadow: 10px 10px 10px rgba(0, 0, 0, 0.2);
`;

const TopicHeaderContainer = styled.div`
  display: flex;
  justify-content: center;
  position: relative;
  align-items: center;
  padding: 16px;
`;

const TopicHeaderTitle = styled.div`
  font-size: ${fontSize.subheading};
  font-weight: bold;
  background-color: ${colors.primary70};
  padding: 8px;
  border-radius: 10px;
`;

const TopicSubsectionHeader = styled.div`
  display: flex;
  width: 100%;
  align-items: center;
  justify-content: space-between;
  font-weight: bold;
`;

const TopicAnswerContainer = styled.div`
  width: 100%;
  display: flex;
  justify-content: space-between;
  align-items: center;
`;

const TopicSubContainer = styled.div`
  display: flex;
  font-size: ${fontSize.label};
  text-align: left;
  flex-direction: column;
  border-radius: 12px;
  padding: 16px;
  width: 100%;
`;

const TopicSubVideoContainer = styled.div`
  display: flex;
  font-size: ${fontSize.label};
  text-align: left;
  margin-bottom: 16px;
  flex-direction: column;
  justify-content: center;
  border-radius: 12px;
  padding: 16px;
  width: 50%;
  min-width: 592px;
`;

const NoVideoText = styled.p`
  font-size: ${fontSize.default};
  font-style: italic;
  color: ${colors.black};
  padding: 8px;
`;

const VideoContainer = styled.div`
  display: flex;
  width: 100%;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  gap: 16px;
`;

const SwitchVideoContainer = styled.div`
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: 8px;
  font-size: ${fontSize.label};
`;

const ChatbotContainer = styled.div`
  display: flex;
  flex: ${({ $isChatbotShown }) => ($isChatbotShown ? "2.5" : "0")};
  overflow: hidden;
  overscroll-behavior: contain;
  height: 100%;
  position: relative;
`;
